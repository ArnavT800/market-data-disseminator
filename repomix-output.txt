This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repomix on: 2025-01-05T10:24:00.753Z

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.

Additional Info:
----------------

For more information about Repomix, visit: https://github.com/yamadashy/repomix

================================================================
Directory Structure
================================================================
claude/
  claude_sample.py
  market_data_client.py
  market_data_server.py
  market_data.proto
client/
  client.py
server/
  globals/
    orderbook_mappings.py
  grpc/
    market_data_pb2_grpc.py
    market_data_pb2.py
    market_data_server.py
    market_data.proto
  models/
    Instrument.py
    OrderBook.py
    OrderBookLevel.py
  services/
    OrderBookService.py
    OrderBookUpdate.py
    parser.py
  config.json
  server.cnf
  server.py
  test.py
.gitignore
main.py

================================================================
Files
================================================================

================
File: claude/claude_sample.py
================
import json
import asyncio
import random
from dataclasses import dataclass
from typing import Dict, List, Optional
from collections import OrderedDict

@dataclass
class Specifications:
    depth: int

@dataclass
class Instrument:
    id: int
    symbol: str
    specifications: Specifications

class OrderbookLevel:
    def __init__(self, price: float, quantity: int):
        self.price = price
        self.quantity = quantity

class OrderbookUpdate:
    def __init__(self, instrument_id: int, update_type: str, level: OrderbookLevel, is_bid: bool):
        self.instrument_id = instrument_id
        self.update_type = update_type  # 'add', 'remove', 'replace'
        self.level = level
        self.is_bid = is_bid

class Orderbook:
    def __init__(self, instrument: Instrument, service):
        self.instrument = instrument
        self.service = service
        self.bids = OrderedDict()  # price -> OrderbookLevel
        self.asks = OrderedDict()  # price -> OrderbookLevel
        self._disposed = False
        self.task = None

    async def start(self):
        self.task = asyncio.create_task(self._generate_updates())

    async def _generate_updates(self):
        while not self._disposed:
            try:
                await asyncio.sleep(random.random() * 2)  # Random delay between updates
                
                # Randomly choose between bid and ask update
                is_bid = random.choice([True, False])
                levels = self.bids if is_bid else self.asks
                
                # Calculate probability of removal based on current depth
                removal_prob = len(levels) / (self.instrument.specifications.depth + 1)
                
                if len(levels) >= self.instrument.specifications.depth:
                    # Must remove or replace when at max depth
                    if random.random() < 0.5:
                        await self._remove_level(is_bid)
                    else:
                        await self._replace_level(is_bid)
                else:
                    # Choose between add, remove, or replace
                    if random.random() < removal_prob:
                        await self._remove_level(is_bid)
                    elif random.random() < 0.3:
                        await self._replace_level(is_bid)
                    else:
                        await self._add_level(is_bid)
                        
            except Exception as ex:
                print(f"Failed to generate orderbook update: {ex}")

    async def _add_level(self, is_bid: bool):
        price = self._generate_price(is_bid)
        quantity = random.randint(1, 1000)
        level = OrderbookLevel(price, quantity)
        
        levels = self.bids if is_bid else self.asks
        levels[price] = level
        
        update = OrderbookUpdate(self.instrument.id, 'add', level, is_bid)
        await self.service.broadcast_update(update)

    async def _remove_level(self, is_bid: bool):
        levels = self.bids if is_bid else self.asks
        if not levels:
            return
            
        price = random.choice(list(levels.keys()))
        level = levels.pop(price)
        
        update = OrderbookUpdate(self.instrument.id, 'remove', level, is_bid)
        await self.service.broadcast_update(update)

    async def _replace_level(self, is_bid: bool):
        levels = self.bids if is_bid else self.asks
        if not levels:
            return
            
        price = random.choice(list(levels.keys()))
        level = OrderbookLevel(price, random.randint(1, 1000))
        levels[price] = level
        
        update = OrderbookUpdate(self.instrument.id, 'replace', level, is_bid)
        await self.service.broadcast_update(update)

    def _generate_price(self, is_bid: bool) -> float:
        # Generate a price that maintains bid-ask spread
        base = 100  # Base price
        spread = 0.1  # Minimum spread
        
        if is_bid:
            max_bid = min(self.asks.keys()) - spread if self.asks else float('inf')
            return random.uniform(base - 10, min(base, max_bid))
        else:
            min_ask = max(self.bids.keys()) + spread if self.bids else float('-inf')
            return random.uniform(max(base, min_ask), base + 10)

    def get_snapshot(self):
        return {
            'bids': [(level.price, level.quantity) for level in self.bids.values()],
            'asks': [(level.price, level.quantity) for level in self.asks.values()]
        }

    def dispose(self):
        self._disposed = True
        if self.task:
            self.task.cancel()

class OrderbookService:
    def __init__(self, port: int):
        self.port = port
        self.clients = set()
        
    async def broadcast_update(self, update: OrderbookUpdate):
        # In a real implementation, this would send updates to connected clients
        # For now, we'll just print the updates
        print(f"Broadcasting update: {update.__dict__}")

class Server:
    def __init__(self, config_path: str):
        self.orderbooks: Dict[int, Orderbook] = {}
        self.service = None
        self.config_path = config_path

    async def start(self):
        # Read configuration
        with open(self.config_path, 'r') as f:
            config = json.load(f)
        
        # Initialize service
        self.service = OrderbookService(config['Port'])
        
        # Create orderbooks for each instrument
        for instr_config in config['Instruments']:
            instrument = Instrument(
                id=instr_config['Id'],
                symbol=instr_config['Symbol'],
                specifications=Specifications(instr_config['Specifications']['Depth'])
            )
            
            orderbook = Orderbook(instrument, self.service)
            self.orderbooks[instrument.id] = orderbook
            await orderbook.start()

    def get_snapshot(self, instrument_id: int):
        if instrument_id not in self.orderbooks:
            raise KeyError(f"Orderbook {instrument_id} does not exist.")
        return self.orderbooks[instrument_id].get_snapshot()

    def dispose(self):
        for orderbook in self.orderbooks.values():
            orderbook.dispose()
        self.orderbooks.clear()

# Example usage
async def main():
    server = Server('appsettings.json')
    await server.start()
    
    try:
        # Keep the server running
        while True:
            await asyncio.sleep(1)
    except KeyboardInterrupt:
        server.dispose()

if __name__ == "__main__":
    asyncio.run(main())

================
File: claude/market_data_client.py
================
import asyncio
import grpc
import market_data_pb2
import market_data_pb2_grpc

class MarketDataClient:
    def __init__(self):
        self.orderbooks = {}  # instrument_id -> current orderbook state
        self.channel = None
        self.stub = None

    async def connect(self, server_address):
        self.channel = grpc.aio.insecure_channel(server_address)
        self.stub = market_data_pb2_grpc.MarketDataServiceStub(self.channel)

    async def run(self):
        async def request_iterator():
            while True:
                request = await self.subscription_queue.get()
                if request is None:
                    break
                yield request

        self.subscription_queue = asyncio.Queue()
        stream = self.stub.StreamMarketData(request_iterator())

        try:
            async for response in stream:
                await self.handle_response(response)
        except Exception as e:
            print(f"Stream error: {e}")
        finally:
            await self.subscription_queue.put(None)

    async def subscribe(self, instrument_id):
        request = market_data_pb2.SubscriptionRequest(
            instrument_id=instrument_id,
            type=market_data_pb2.SubscriptionRequest.SUBSCRIBE
        )
        await self.subscription_queue.put(request)

    async def unsubscribe(self, instrument_id):
        request = market_data_pb2.SubscriptionRequest(
            instrument_id=instrument_id,
            type=market_data_pb2.SubscriptionRequest.UNSUBSCRIBE
        )
        await self.subscription_queue.put(request)

    async def handle_response(self, response):
        if response.type == market_data_pb2.MarketDataResponse.SNAPSHOT:
            # Replace entire orderbook state
            self.orderbooks[response.instrument_id] = {
                'bids': {level.price: level.quantity for level in response.data.bids},
                'asks': {level.price: level.quantity for level in response.data.asks}
            }
        elif response.type == market_data_pb2.MarketDataResponse.INCREMENT:
            # Apply incremental update
            self.apply_update(response.instrument_id, response.data)
        elif response.type == market_data_pb2.MarketDataResponse.CLEAR:
            # Clear orderbook state on unsubscribe
            if response.instrument_id in self.orderbooks:
                del self.orderbooks[response.instrument_id]

    def apply_update(self, instrument_id, update):
        # Implementation depends on your update structure
        pass

# Example usage
async def main():
    client = MarketDataClient()
    await client.connect('localhost:50051')
    
    # Start client in background
    client_task = asyncio.create_task(client.run())
    
    # Subscribe to some instruments
    await client.subscribe(1)
    await client.subscribe(2)
    
    # Wait for some updates
    await asyncio.sleep(30)
    
    # Unsubscribe
    await client.unsubscribe(1)
    await client.unsubscribe(2)
    
    # Cleanup
    client_task.cancel()
    await client.channel.close()

if __name__ == '__main__':
    asyncio.run(main())

================
File: claude/market_data_server.py
================
import grpc
from concurrent import futures
import asyncio
from collections import defaultdict
import market_data_pb2
import market_data_pb2_grpc

class MarketDataServicer(market_data_pb2_grpc.MarketDataServiceServicer):
    def __init__(self, orderbook_service):
        self.orderbook_service = orderbook_service
        self.client_subscriptions = defaultdict(set)
        self.client_queues = {}

    async def StreamMarketData(self, request_iterator, context):
        # Create queue for this client
        client_id = context.peer()
        queue = asyncio.Queue()
        self.client_queues[client_id] = queue

        # Start subscription handler
        asyncio.create_task(self.handle_subscriptions(request_iterator, client_id, context))

        try:
            while True:
                # Wait for data from the queue
                response = await queue.get()
                if response is None:  # Sentinel value for shutdown
                    break
                yield response
        finally:
            # Cleanup on disconnect
            await self.cleanup_client(client_id)

    async def handle_subscriptions(self, request_iterator, client_id, context):
        try:
            async for request in request_iterator:
                if request.type == market_data_pb2.SubscriptionRequest.SUBSCRIBE:
                    await self.handle_subscribe(client_id, request.instrument_id)
                else:
                    await self.handle_unsubscribe(client_id, request.instrument_id)
        except Exception as e:
            print(f"Subscription handler error: {e}")
            await self.cleanup_client(client_id)

    async def handle_subscribe(self, client_id, instrument_id):
        # Add to subscriptions
        self.client_subscriptions[client_id].add(instrument_id)
        
        # Send initial snapshot
        snapshot = self.orderbook_service.get_snapshot(instrument_id)
        response = self.create_snapshot_response(instrument_id, snapshot)
        await self.client_queues[client_id].put(response)

    async def handle_unsubscribe(self, client_id, instrument_id):
        if instrument_id in self.client_subscriptions[client_id]:
            self.client_subscriptions[client_id].remove(instrument_id)
            
            # Send clear notification
            clear_response = market_data_pb2.MarketDataResponse(
                instrument_id=instrument_id,
                type=market_data_pb2.MarketDataResponse.CLEAR
            )
            await self.client_queues[client_id].put(clear_response)

    async def cleanup_client(self, client_id):
        if client_id in self.client_queues:
            await self.client_queues[client_id].put(None)
            del self.client_queues[client_id]
        if client_id in self.client_subscriptions:
            del self.client_subscriptions[client_id]

    def broadcast_update(self, instrument_id, update):
        # Convert update to protobuf response
        response = self.create_increment_response(instrument_id, update)
        
        # Send to all subscribed clients
        for client_id, subscriptions in self.client_subscriptions.items():
            if instrument_id in subscriptions:
                asyncio.create_task(self.client_queues[client_id].put(response))

    def broadcast_snapshot(self, instrument_id):
        # Get current snapshot
        snapshot = self.orderbook_service.get_snapshot(instrument_id)
        response = self.create_snapshot_response(instrument_id, snapshot)
        
        # Send to all subscribed clients
        for client_id, subscriptions in self.client_subscriptions.items():
            if instrument_id in subscriptions:
                asyncio.create_task(self.client_queues[client_id].put(response))

    @staticmethod
    def create_snapshot_response(instrument_id, snapshot):
        return market_data_pb2.MarketDataResponse(
            instrument_id=instrument_id,
            type=market_data_pb2.MarketDataResponse.SNAPSHOT,
            data=market_data_pb2.OrderBookData(
                bids=[market_data_pb2.PriceLevel(price=p, quantity=q) 
                     for p, q in snapshot['bids']],
                asks=[market_data_pb2.PriceLevel(price=p, quantity=q) 
                     for p, q in snapshot['asks']]
            )
        )

    @staticmethod
    def create_increment_response(instrument_id, update):
        # Convert your update object to protobuf response
        pass  # Implementation depends on your update structure

================
File: claude/market_data.proto
================
# market_data.proto
syntax = "proto3";

package marketdata;

service MarketDataService {
    // Bidirectional streaming RPC
    rpc StreamMarketData (stream SubscriptionRequest) returns (stream MarketDataResponse) {}
}

message SubscriptionRequest {
    int32 instrument_id = 1;
    enum RequestType {
        SUBSCRIBE = 0;
        UNSUBSCRIBE = 1;
    }
    RequestType type = 2;
}

message MarketDataResponse {
    int32 instrument_id = 1;
    enum UpdateType {
        SNAPSHOT = 0;
        INCREMENT = 1;
        CLEAR = 2;  // For unsubscribe notifications
    }
    UpdateType type = 2;
    OrderBookData data = 3;
}

message OrderBookData {
    repeated PriceLevel bids = 1;
    repeated PriceLevel asks = 2;
}

message PriceLevel {
    double price = 1;
    int32 quantity = 2;
}

================
File: client/client.py
================
import sys
import os
sys.path.append(os.path.dirname(os.path.dirname(os.path.abspath(__file__))))
import server.grpc.market_data_pb2
import server.grpc.market_data_pb2_grpc
import grpc
import asyncio
import pdb
import traceback

class MarketDataClient:
    def __init__(self):
        self.channel = None
        self.stub = None
        self.subscription_queue = asyncio.Queue()
    
    def connect(self, server_address):
        with open('server.crt', 'rb') as cert_file:
            server_cert = cert_file.read()
        options = (('grpc.ssl_target_name_override', 'localhost'),)

        credentials = grpc.ssl_channel_credentials(root_certificates=server_cert)
        self.channel = grpc.aio.secure_channel(
            server_address, 
            credentials, 
            options
        )
        self.stub = server.grpc.market_data_pb2_grpc.MarketDataServiceStub(self.channel)
    
    async def run(self):
        async def request_iterator():
            while True:
                request = await self.subscription_queue.get()
                if request is None:
                    continue
                yield request

        stream = self.stub.StreamMarketData(request_iterator())
        try:
            async for response in stream:
                await self.handle_response(response)
        except Exception as e:
            print(f"Stream error {e}")
            traceback.print_exc()
        finally:
            await self.subscription_queue.put(None)
    
    async def subscribe(self, instrument_id):
        request = server.grpc.market_data_pb2.SubscriptionRequest(
            instrument_id = instrument_id,
            type = server.grpc.market_data_pb2.SubscriptionRequest.SUBSCRIBE
        )

        await self.subscription_queue.put(request)

    async def unsubscribe(self, instrument_id):
        request = server.grpc.market_data_pb2.SubscriptionRequest(
            instrument_id = instrument_id,
            type = server.grpc.market_data_pb2.SubscriptionRequest.UNSUBSCRIBE
        )

        await self.subscription_queue.put(request)
    
    async def handle_response(self, response):
        if response.type == server.grpc.market_data_pb2.MarketDataResponse.SNAPSHOT:
            self.handle_snapshot(response)
        elif response.type == server.grpc.market_data_pb2.MarketDataResponse.INCREMENTAL:
            self.handle_incremental_update(response)
        elif response.type == server.grpc.market_data_pb2.MarketDataResponse.ERROR:
            self.handle_error(response)
        else:
            self.handle_unsubscribe(response)
    
    def handle_snapshot(self, response):
        print(f"Orderbook for {response.instrument_id}")
        print("-------------")
        print("Bids")
        for level in response.orderbook_data.bids:
            print(f"${level.price}: {level.quantity} units")
        print("-------------")
        print("Asks")
        for level in response.orderbook_data.asks:
             print(f"${level.price}: {level.quantity} units")
        
    def handle_incremental_update(self, response):
        update_mappings = {
            server.grpc.market_data_pb2.OrderBookUpdate.ADD: "Adding",
            server.grpc.market_data_pb2.OrderBookUpdate.REMOVE: "Removing", 
            server.grpc.market_data_pb2.OrderBookUpdate.REPLACE: "Replacing"
        }

        bid_or_ask = "Bid" if response.is_bid else "Ask"

        print(f"{update_mappings[response.orderbook_data.type]} Orderbook {response.instrument_id} Level on {bid_or_ask} section: Price ${response.update_data.level.price} @ {response.update_data.level.quantiy} units")

    def handle_unsubscribe(self, response):
        print(f"Unsubscribing from instrument {response.instrument_id}")
    
    def handle_error(self, response):
        print(f"{response.message}")

async def main():
    client = MarketDataClient()
    client.connect('localhost:3000')

    client_task = asyncio.create_task(client.run())
    await client.subscribe(1)
    try:
        while True:
            await asyncio.sleep(1)
    except KeyboardInterrupt:
        client_task.cancel()
        await client.channel.close()  
    # try:
    #     await asyncio.sleep(5)
    #     # await client.subscribe(1)
    #     # await client.subscribe(2)

    #     # await asyncio.sleep(30)

    #     # await client.unsubscribe(1)
    #     # await client.unsubscribe(2)
    # except:
    #     print(0)
    #     # client_task.cancel()
    #     # await client.channel.close()

if __name__ == "__main__":
    asyncio.run(main())

================
File: server/globals/orderbook_mappings.py
================
# Global variable that maps instrument ids to orderbooks

ORDERBOOKS = {}

================
File: server/grpc/market_data_pb2_grpc.py
================
# Generated by the gRPC Python protocol compiler plugin. DO NOT EDIT!
"""Client and server classes corresponding to protobuf-defined services."""
import grpc
import warnings

import server.grpc.market_data_pb2 as market__data__pb2

GRPC_GENERATED_VERSION = '1.68.1'
GRPC_VERSION = grpc.__version__
_version_not_supported = False

try:
    from grpc._utilities import first_version_is_lower
    _version_not_supported = first_version_is_lower(GRPC_VERSION, GRPC_GENERATED_VERSION)
except ImportError:
    _version_not_supported = True

if _version_not_supported:
    raise RuntimeError(
        f'The grpc package installed is at version {GRPC_VERSION},'
        + f' but the generated code in market_data_pb2_grpc.py depends on'
        + f' grpcio>={GRPC_GENERATED_VERSION}.'
        + f' Please upgrade your grpc module to grpcio>={GRPC_GENERATED_VERSION}'
        + f' or downgrade your generated code using grpcio-tools<={GRPC_VERSION}.'
    )


class MarketDataServiceStub(object):
    """Missing associated documentation comment in .proto file."""

    def __init__(self, channel):
        """Constructor.

        Args:
            channel: A grpc.Channel.
        """
        self.StreamMarketData = channel.stream_stream(
                '/marketdata.MarketDataService/StreamMarketData',
                request_serializer=market__data__pb2.SubscriptionRequest.SerializeToString,
                response_deserializer=market__data__pb2.MarketDataResponse.FromString,
                _registered_method=True)


class MarketDataServiceServicer(object):
    """Missing associated documentation comment in .proto file."""

    def StreamMarketData(self, request_iterator, context):
        """Missing associated documentation comment in .proto file."""
        context.set_code(grpc.StatusCode.UNIMPLEMENTED)
        context.set_details('Method not implemented!')
        raise NotImplementedError('Method not implemented!')


def add_MarketDataServiceServicer_to_server(servicer, server):
    rpc_method_handlers = {
            'StreamMarketData': grpc.stream_stream_rpc_method_handler(
                    servicer.StreamMarketData,
                    request_deserializer=market__data__pb2.SubscriptionRequest.FromString,
                    response_serializer=market__data__pb2.MarketDataResponse.SerializeToString,
            ),
    }
    generic_handler = grpc.method_handlers_generic_handler(
            'marketdata.MarketDataService', rpc_method_handlers)
    server.add_generic_rpc_handlers((generic_handler,))
    server.add_registered_method_handlers('marketdata.MarketDataService', rpc_method_handlers)


 # This class is part of an EXPERIMENTAL API.
class MarketDataService(object):
    """Missing associated documentation comment in .proto file."""

    @staticmethod
    def StreamMarketData(request_iterator,
            target,
            options=(),
            channel_credentials=None,
            call_credentials=None,
            insecure=False,
            compression=None,
            wait_for_ready=None,
            timeout=None,
            metadata=None):
        return grpc.experimental.stream_stream(
            request_iterator,
            target,
            '/marketdata.MarketDataService/StreamMarketData',
            market__data__pb2.SubscriptionRequest.SerializeToString,
            market__data__pb2.MarketDataResponse.FromString,
            options,
            channel_credentials,
            insecure,
            call_credentials,
            compression,
            wait_for_ready,
            timeout,
            metadata,
            _registered_method=True)

================
File: server/grpc/market_data_pb2.py
================
# -*- coding: utf-8 -*-
# Generated by the protocol buffer compiler.  DO NOT EDIT!
# NO CHECKED-IN PROTOBUF GENCODE
# source: market_data.proto
# Protobuf Python Version: 5.28.1
"""Generated protocol buffer code."""
from google.protobuf import descriptor as _descriptor
from google.protobuf import descriptor_pool as _descriptor_pool
from google.protobuf import runtime_version as _runtime_version
from google.protobuf import symbol_database as _symbol_database
from google.protobuf.internal import builder as _builder
_runtime_version.ValidateProtobufRuntimeVersion(
    _runtime_version.Domain.PUBLIC,
    5,
    28,
    1,
    '',
    'market_data.proto'
)
# @@protoc_insertion_point(imports)

_sym_db = _symbol_database.Default()




DESCRIPTOR = _descriptor_pool.Default().AddSerializedFile(b'\n\x11market_data.proto\x12\nmarketdata\"\x96\x01\n\x13SubscriptionRequest\x12\x15\n\rinstrument_id\x18\x01 \x01(\x05\x12\x39\n\x04type\x18\x02 \x01(\x0e\x32+.marketdata.SubscriptionRequest.RequestType\"-\n\x0bRequestType\x12\r\n\tSUBSCRIBE\x10\x00\x12\x0f\n\x0bUNSUBSCRIBE\x10\x01\"(\n\x05Level\x12\r\n\x05price\x18\x01 \x01(\x02\x12\x10\n\x08quantity\x18\x02 \x01(\x05\"Q\n\rOrderBookData\x12\x1f\n\x04\x62ids\x18\x01 \x03(\x0b\x32\x11.marketdata.Level\x12\x1f\n\x04\x61sks\x18\x02 \x03(\x0b\x32\x11.marketdata.Level\"\xa7\x02\n\x12MarketDataResponse\x12\x15\n\rinstrument_id\x18\x01 \x01(\x05\x12\x39\n\x04type\x18\x02 \x01(\x0e\x32+.marketdata.MarketDataResponse.ResponseType\x12\x31\n\x0eorderbook_data\x18\x03 \x01(\x0b\x32\x19.marketdata.OrderBookData\x12\x30\n\x0bupdate_data\x18\x04 \x01(\x0b\x32\x1b.marketdata.OrderBookUpdate\x12\x0f\n\x07message\x18\x05 \x01(\t\"I\n\x0cResponseType\x12\x0c\n\x08SNAPSHOT\x10\x00\x12\x0f\n\x0bINCREMENTAL\x10\x01\x12\t\n\x05\x45RROR\x10\x02\x12\x0f\n\x0bUNSUBSCRIBE\x10\x03\"\xa9\x01\n\x0fOrderBookUpdate\x12\x34\n\x04type\x18\x01 \x01(\x0e\x32&.marketdata.OrderBookUpdate.UpdateType\x12\x0e\n\x06is_bid\x18\x02 \x01(\x08\x12 \n\x05level\x18\x03 \x01(\x0b\x32\x11.marketdata.Level\".\n\nUpdateType\x12\x07\n\x03\x41\x44\x44\x10\x00\x12\x0b\n\x07REPLACE\x10\x01\x12\n\n\x06REMOVE\x10\x02\x32l\n\x11MarketDataService\x12W\n\x10StreamMarketData\x12\x1f.marketdata.SubscriptionRequest\x1a\x1e.marketdata.MarketDataResponse(\x01\x30\x01\x62\x06proto3')

_globals = globals()
_builder.BuildMessageAndEnumDescriptors(DESCRIPTOR, _globals)
_builder.BuildTopDescriptorsAndMessages(DESCRIPTOR, 'market_data_pb2', _globals)
if not _descriptor._USE_C_DESCRIPTORS:
  DESCRIPTOR._loaded_options = None
  _globals['_SUBSCRIPTIONREQUEST']._serialized_start=34
  _globals['_SUBSCRIPTIONREQUEST']._serialized_end=184
  _globals['_SUBSCRIPTIONREQUEST_REQUESTTYPE']._serialized_start=139
  _globals['_SUBSCRIPTIONREQUEST_REQUESTTYPE']._serialized_end=184
  _globals['_LEVEL']._serialized_start=186
  _globals['_LEVEL']._serialized_end=226
  _globals['_ORDERBOOKDATA']._serialized_start=228
  _globals['_ORDERBOOKDATA']._serialized_end=309
  _globals['_MARKETDATARESPONSE']._serialized_start=312
  _globals['_MARKETDATARESPONSE']._serialized_end=607
  _globals['_MARKETDATARESPONSE_RESPONSETYPE']._serialized_start=534
  _globals['_MARKETDATARESPONSE_RESPONSETYPE']._serialized_end=607
  _globals['_ORDERBOOKUPDATE']._serialized_start=610
  _globals['_ORDERBOOKUPDATE']._serialized_end=779
  _globals['_ORDERBOOKUPDATE_UPDATETYPE']._serialized_start=733
  _globals['_ORDERBOOKUPDATE_UPDATETYPE']._serialized_end=779
  _globals['_MARKETDATASERVICE']._serialized_start=781
  _globals['_MARKETDATASERVICE']._serialized_end=889
# @@protoc_insertion_point(module_scope)

================
File: server/grpc/market_data_server.py
================
import grpc
import market_data_pb2
import market_data_pb2_grpc
import asyncio
import collections
import concurrent

class MarketDataServicer(market_data_pb2_grpc.MarketDataServiceServicer):
    def __init__(self, orderbook_service):
        self.orderbook_service = orderbook_service

================
File: server/grpc/market_data.proto
================
syntax = "proto3";
package marketdata;

message SubscriptionRequest {
    int32 instrument_id = 1;
    enum RequestType {
        SUBSCRIBE = 0;
        UNSUBSCRIBE = 1;
    }
    RequestType type = 2;
}

message Level {
    float price = 1;
    int32 quantity = 2;
}

message OrderBookData {
    repeated Level bids = 1;
    repeated Level asks = 2;
}

message MarketDataResponse {
    int32 instrument_id = 1;
    enum ResponseType {
        SNAPSHOT = 0;
        INCREMENTAL = 1;
        ERROR = 2;
        UNSUBSCRIBE = 3;
    }
    ResponseType type = 2;
    OrderBookData orderbook_data = 3;  // For snapshots
    OrderBookUpdate update_data = 4;    // For incremental updates
    string message = 5;                 // For errors and unsubscribe messages
}

message OrderBookUpdate {
    enum UpdateType {
        ADD = 0;
        REPLACE = 1;
        REMOVE = 2;
    }
    UpdateType type = 1;
    bool is_bid = 2;
    Level level = 3;
}

service MarketDataService {
    rpc StreamMarketData (stream SubscriptionRequest) returns (stream MarketDataResponse);
}

================
File: server/models/Instrument.py
================
class Instrument:
    def __init__(self, id, symbol, orderbook_depth):
        self.id = id
        self.symbol = symbol
        self.orderbook_depth = orderbook_depth
    def __repr__(self):
        return f"Instrument(id = {self.id}), symbol = {self.symbol}, orderbook_depth = {self.orderbook_depth})"

================
File: server/models/OrderBook.py
================
import collections
import random
import asyncio
from server.services.OrderBookUpdate import OrderBookUpdate

class OrderBook:
    def __init__(self, instrument, service):
        self.instrument = instrument
        self.service = service
        self.depth = instrument.orderbook_depth
        self.bids = collections.OrderedDict()
        self.asks = collections.OrderedDict()
        self.disposed = False
        self.task = None

    async def generate_updates(self):
        while not self.disposed:
            try:
                await asyncio.sleep(random.random() * 2)

                if random.random() > 0.95:
                    snapshot = self.get_snapshot()
                    await self.service.broadcast_snapshot(snapshot, self.instrument)
                else:
                    update = OrderBookUpdate(self, self.depth)
                    update.update()
                    await self.service.broadcast_update(update)
                
            except Exception as ex:
                print(f"Failed to update orderbook, {update}: {ex}")

    async def start(self):
        self.task = asyncio.create_task(self.generate_updates())
        
    def get_snapshot(self):
        return {
            'bids': [(level.price, level.quantity) for level in self.bids.values()],
            'asks': [(level.price, level.quantity) for level in self.asks.values()]
        }

    def dispose(self):
        self.disposed = True
        if self.task:
            self.task.cancel()

================
File: server/models/OrderBookLevel.py
================
class OrderBookLevel:
    def __init__(self, price, quantity):
        self.price = price
        self.quantity = quantity
    def __str__(self):
        return f"Price ${self.price}, {self.quantity} units"

================
File: server/services/OrderBookService.py
================
import server.grpc
import server.grpc.market_data_pb2_grpc
import server.grpc.market_data_pb2
import grpc
import concurrent
import asyncio
import collections
import server.globals.orderbook_mappings
import pdb

class OrderBookService(server.grpc.market_data_pb2_grpc.MarketDataServiceServicer):
    def __init__(self, port):
        self.port = port
        self.client_subscriptions = collections.defaultdict(set)
        self.client_queues = {}
    
    async def StreamMarketData(self, request_iterator, context):
        # pdb.set_trace()
        client_address = context.peer()
        queue = asyncio.Queue()
        self.client_queues[client_address] = queue

        asyncio.create_task(self.handle_subscriptions(request_iterator, client_address, context))
        print("goes here")
        try:
            while True:
                response = await queue.get()
                if response is None:
                    break
                yield response
        finally:
            await self.cleanup_client(client_address)
    
    async def handle_subscriptions(self, request_iterator, client_address, context):
        try:
            async for request in request_iterator:
                if request.type == server.grpc.market_data_pb2.SubscriptionRequest.SUBSCRIBE:
                    await self.handle_subscribe(client_address, request.instrument_id)
                else:
                    await self.handle_unsubscribe(client_address, request.instrument_id)
        except Exception as e:
            print(f"Problem with handling subscription: {e}")
            await self.cleanup_client(client_address)
    
    async def cleanup_client(self, client_address):
        if client_address in self.client_queues:
            await self.client_queues[client_address].put(None)
            del self.client_queues[client_address]
        if client_address in self.client_subscriptions:
            del self.client_subscriptions[client_address]
    
    async def handle_subscribe(self, client_address, instrument_id):
        if instrument_id in self.client_subscriptions[client_address]:
           print(f"Client {client_address} already subscribed to {instrument_id}")
           response = self.create_failure_response(client_address, instrument_id)
           await self.client_queues[client_address].put(response)
           return

        self.client_subscriptions[client_address].add(instrument_id)
        print(f"Client {client_address} successfully subscribed to {instrument_id}")
        current_orderbook_object = server.globals.orderbook_mappings.ORDERBOOKS[instrument_id]
        snapshot = current_orderbook_object.get_snapshot()

        response = self.create_snapshot_response(instrument_id, snapshot)
        await self.client_queues[client_address].put(response)
    
    async def handle_unsubscribe(self, client_address, instrument_id):
        if instrument_id not in self.client_subscriptions[client_address]:
            print(f"Client {client_address} not subscribed to {instrument_id}")
            response = self.create_failure_response(instrument_id, client_address)
            await self.client_queues[client_address].put(response)
            return
        
        self.client_subscriptions[client_address].discard(instrument_id)
        response = self.create_unsub_response(instrument_id, client_address)
        await self.client_queues[client_address].put(response)

    def create_failure_response(self, instrument_id, client_address):
        error_message = server.grpc.market_data_pb2.ErrorResponse(
            error = f"Subscription/unsubscription mechanism failed for {client_address} to {instrument_id}"
        )
        return server.grpc.market_data_pb2.MarketDataResponse(
            instrument_id = instrument_id,
            type = server.grpc.market_data_pb2.MarketDataResponse.ERROR,
            message = error_message
        )
    
    def create_snapshot_response(self, instrument_id, snapshot):
        return server.grpc.market_data_pb2.MarketDataResponse(
            instrument_id = instrument_id,
            type = server.grpc.market_data_pb2.MarketDataResponse.SNAPSHOT,
            orderbook_data = server.grpc.market_data_pb2.OrderBookData(
                bids = [
                    server.grpc.market_data_pb2.Level(price = price, quantity = quantity)
                    for price, quantity in snapshot['bids']
                ],
                asks = [
                    server.grpc.market_data_pb2.Level(price = price, quantity = quantity)
                    for price, quantity in snapshot['asks']
                ]
            ),
            message = f"New snapshot for {instrument_id}"
        )
    
    def create_incremental_update_response(self, instrument_id, update):
        update_mappings = {
            "Adding": server.grpc.market_data_pb2.OrderBookUpdate.ADD,
            "Removing": server.grpc.market_data_pb2.OrderBookUpdate.REMOVE,
            "Replacing": server.grpc.market_data_pb2.OrderBookUpdate.REPLACE
        }

        return server.grpc.market_data_pb2.MarketDataResponse(
            instrument_id = instrument_id,
            type = server.grpc.market_data_pb2.MarketDataResponse.INCREMENTAL,
            update_data = server.grpc.market_data_pb2.OrderBookUpdate(
                type = update_mappings[update.action],
                is_bid = update.is_bid,
                level = server.grpc.market_data_pb2.Level(
                    price = update.level.price,
                    quantity = update.level.quantity
                )
            )
        )
    
    def create_unsub_response(self, instrument_id, client_address):
        unsubscribe_message = f"Client {client_address} successfully unsubscribed from instrument {instrument_id}"
        return server.grpc.market_data_pb2.MarketDataResponse(
            instrument_id = instrument_id,
            type = server.grpc.market_data_pb2.MarketDataResponse.UNSUBSCRIBE,
            message = unsubscribe_message
        )

    async def broadcast_update(self, update):
        if not update.action:
            return
        
        streaming_instrument_id = update.orderbook.instrument.id
        response = self.create_incremental_update_response(streaming_instrument_id, update)
        for client_address, subscriptions in self.client_subscriptions.items():
            if streaming_instrument_id in subscriptions:
                try:
                    await self.client_queues[client_address].put(response)
                except Exception as e:
                    print(f"Failed streaming updates for instrument {streaming_instrument_id} to client {client_address}: {e}") 

            
    async def broadcast_snapshot(self, snapshot, instrument):
        response = self.create_snapshot_response(instrument.id, snapshot)
        for client_address, subscriptions in self.client_subscriptions.items():
            if instrument.id in subscriptions:
                try: 
                    await self.client_queues[client_address].put(response)
                except Exception as e:
                    print(f"Failed streaming snapshot for instrument {instrument.id} to client {client_address}: {e}")

================
File: server/services/OrderBookUpdate.py
================
import random
from server.models.OrderBookLevel import OrderBookLevel

class OrderBookUpdate:
    def __init__(self, orderbook, depth):
        self.orderbook = orderbook
        self.depth = depth
        self.is_bid = random.choice([True, False])
        self.entries = orderbook.bids if self.is_bid else orderbook.asks
        self.action = None # ["add", "replace", "remove"]
        self.level = None

    def __str__(self):
        return f"{self.entries}, {self.depth}, {self.action}"

    def update(self):
        if len(self.entries) >= self.depth:
            if random.random() < 0.5:
                self.remove_level()
            else:
                self.replace_level()
        else:
            removal_prob = len(self.entries) / (self.depth + 1)
            if random.random() < removal_prob:
                self.remove_level()
            elif random.random() < 0.3:
                self.replace_level()
            else:
                self.add_level()
    
    def generate_price(self):
        base_price = 100
        spread = 0.1

        if self.is_bid:
            max_bid = min(self.orderbook.asks.keys()) - spread if self.orderbook.asks else float('inf')
            return round(random.uniform(base_price - 10, min(base_price, max_bid)), 2)
        else:
            min_ask = max(self.orderbook.bids.keys()) + spread if self.orderbook.bids else float('-inf')
            return round(random.uniform(max(base_price, min_ask), base_price + 10), 2)
        
    def remove_level(self):
        if len(self.entries) == 0:
            return
        price_point = random.choice(list(self.entries.keys()))
        self.level = self.entries.pop(price_point)
        self.action = "Removing"

    def replace_level(self):
        if len(self.entries) == 0:
            return
        price = random.choice(list(self.entries.keys()))
        self.level = OrderBookLevel(price, random.randint(1, 1000))
        self.entries[price] = self.level
        self.action = "Replacing"
    
    def add_level(self):
        price = self.generate_price()
        quantity = random.randint(1, 1000)
        level = OrderBookLevel(price, quantity)

        self.entries[price] = level
        self.level = level
        self.action = "Adding"

================
File: server/services/parser.py
================
import json
from server.models.Instrument import Instrument

def load_data(config_path):
    with open(config_path, "r") as file:
        data = json.load(file)
    port = data['Port']
    instruments = []
    for instrument in data['Instruments']:
        instruments.append(Instrument(
            id=instrument['Id'],
            symbol = instrument['Symbol'],
            orderbook_depth = instrument['Specs']['OrderBookDepth']
        ))
    return [port, instruments]

================
File: server/config.json
================
{
    "Port": 50051,
    "Instruments": [
        {
            "Id": 1,
            "Symbol": "AAPL",
            "Specs": {
                "OrderBookDepth": 10 
            }
        },

        {
            "Id": 2,
            "Symbol": "GOOG",
            "Specs": {
                "OrderBookDepth": 5
            }
        }
    ]
}

================
File: server/server.cnf
================
[req]
distinguished_name = req_distinguished_name
req_extensions = v3_req
prompt = no

[req_distinguished_name]
C = US
ST = State
L = City
O = Organization
OU = Unit
CN = localhost

[v3_req]
basicConstraints = CA:FALSE
keyUsage = nonRepudiation, digitalSignature, keyEncipherment
subjectAltName = @alt_names

[alt_names]
DNS.1 = localhost
IP.1 = 127.0.0.1

================
File: server/server.py
================
import server.globals.orderbook_mappings
from server.services.parser import load_data
from server.services.OrderBookService import OrderBookService
from server.models.OrderBook import OrderBook
import server.globals
import grpc
import server.grpc.market_data_pb2_grpc

class Server:
    def __init__(self, config_path):
        self.orderbooks = {}
        self.service = None
        self.config_path = config_path
        self.grpc_server = None

    async def start(self):
        print("Starting server...")
        config = load_data(self.config_path)
        self.service = OrderBookService(config[0])

        self.grpc_server = grpc.aio.server()
        server.grpc.market_data_pb2_grpc.add_MarketDataServiceServicer_to_server(self.service, self.grpc_server)
        server_address = 'localhost:3000'

        with open('server/server.crt', 'rb') as cert_file:
            certificate_chain = cert_file.read()
        
        with open('server/server.key', 'rb') as key_file:
            private_key = key_file.read()

        credentials = grpc.ssl_server_credentials(
            [(private_key, certificate_chain)]
        )
        self.grpc_server.add_secure_port(server_address, credentials)
        await self.grpc_server.start()
        print(f"gRPC server listening on {server_address}")


        for instrument in config[1]:
            orderbook = OrderBook(instrument, self.service)
            self.orderbooks[instrument.id] = orderbook

            server.globals.orderbook_mappings.ORDERBOOKS[instrument.id] = orderbook
            
            await orderbook.start()
    
    def get_snapshot(self, instrument_id):
        if instrument_id not in self.orderbooks:
            raise KeyError(f"Orderbook {instrument_id} not found")
        return self.orderbooks[instrument_id].get_snapshot()
    
    def dispose(self):
        print("Closing server...")
        for orderbook in self.orderbooks.values():
            orderbook.dispose()
        self.orderbooks.clear()

================
File: server/test.py
================
import sys
print(sys.path)

================
File: .gitignore
================
server/server.key
server/server.crt
server/server.csr
client/server.crt

================
File: main.py
================
from server.server import Server
import asyncio

async def main():
    server = Server("./server/config.json")
    await server.start()

    try:
        while True:
            await asyncio.sleep(1)
    except KeyboardInterrupt:
        server.dispose()
        
if __name__ == "__main__":
    asyncio.run(main())
